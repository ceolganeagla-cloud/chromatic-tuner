<!doctype html>  
<html lang="en">  
<head>  
<!-- Favicon and App Icons -->  
<link rel="icon" type="image/png" sizes="16x16" href="icons/icon-32.png?v=2">  
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32.png?v=2">  
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png?v=2">  
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png?v=2">  
<link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192.png?v=2">  
<link rel="manifest" href="manifest.webmanifest">  
<meta name="theme-color" content="#000000">  
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<style>  
:root{  
  --bg:#0b1220; --panel:#0f172a; --card:#0c1324; --ink:#eaf2ff; --muted:#a4b0c0; --line:#1f2a44;  
  --ok:#22c55e; --low:#ff8a1f; --high:#ef4444; --bar:#111a2e; --bar-edge:#1a2744; --glow:0 10px 30px rgba(0,0,0,.45);  
}  
*{box-sizing:border-box}  
html,body{
  height:100%; margin:0; background:var(--bg); color:var(--ink);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;
  overflow:hidden; overscroll-behavior:none;
}
.wrap{
  display:grid; grid-template-rows:auto auto auto auto 1fr auto; gap:12px;
  height:100svh; max-height:100svh; padding:14px; overflow:hidden;
}
header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}  
h1{margin:0;font-size:clamp(18px,4.5vw,28px);letter-spacing:.3px}  
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}  
button{  
  appearance:none;border:1px solid var(--line);background:var(--panel);color:var(--ink);  
  padding:10px 14px;border-radius:14px;font-weight:700;cursor:pointer;box-shadow:var(--glow)  
}  
button.toggle.start{background:#16a34a;color:white;border-color:#106c31}  
button.toggle.stop{background:#b91c1c;color:white;border-color:#7f1212}  
.badge{padding:8px 12px;border-radius:999px;background:var(--panel);border:1px solid var(--line);font-weight:700;color:var(--muted)}  
.panel{background:var(--panel);border:1px solid var(--line);border-radius:18px;padding:12px;box-shadow:var(--glow)}  
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}  

/* Logo + flag row */
.brand{display:flex;align-items:center;gap:12px;flex-wrap:wrap}  
.brand img.logo{height:36px;width:auto;border-radius:8px;display:block}  
.flag{
  position:relative;
  display:inline-grid;
  grid-template-columns:1fr 1fr 1fr;
  width:40px; height:26px;
  border-radius:5px; overflow:hidden;
  border:1px solid rgba(255,255,255,.18);
  box-shadow:0 0 6px rgba(0,0,0,.4), inset 0 0 4px rgba(255,255,255,.15);
  animation:flagWave 4s ease-in-out infinite;
}
.flag div:nth-child(1){background:linear-gradient(135deg,#169B62 0%,#0f8a54 100%);}  
.flag div:nth-child(2){background:linear-gradient(135deg,#ffffff 0%,#e9edf3 100%);}  
.flag div:nth-child(3){background:linear-gradient(135deg,#FF883E 0%,#d96b1f 100%);}  
@keyframes flagWave{
  0%,100%{transform:skewY(0deg) scaleY(1);}
  50%{transform:skewY(2deg) scaleY(1.03);}
}

/* Instrument chips */  
.tray{display:flex;flex-wrap:wrap;gap:8px}  
.instrument-btn{  
  display:flex;align-items:center;gap:8px;padding:10px 12px;border-radius:14px;  
  background:var(--card);border:1px solid var(--line);cursor:pointer;font-weight:800;color:var(--ink)  
}  
.instrument-btn.active{outline:2px solid #3b82f6}  
.instrument-btn.tuned{background:#0e2919;border-color:#1f8a4e}  

/* Dropdowns */  
.tuning-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}  
select{  
  appearance:none;border:1px solid var(--line);background:var(--card);color:var(--ink);  
  padding:10px 12px;border-radius:12px;font-weight:700;box-shadow:var(--glow)  
}  

/* Tuning readout + string chips */  
.tuning{display:flex;gap:8px;align-items:center;flex-wrap:wrap;color:var(--muted)}  
.string-row{display:flex;gap:6px;flex-wrap:wrap}  
.string-chip{  
  padding:6px 10px;border:1px solid var(--line);background:var(--card);border-radius:999px;font-weight:800;color:var(--ink);  
  min-width:44px;text-align:center  
}  
.string-chip.active{outline:2px solid #3b82f6}  
.string-chip.tuned{background:#0e2919;border-color:#1f8a4e}  

/* Bar */  
.bar-wrap{display:grid;gap:12px}  
.bar{  
  position:relative;height:36px;border-radius:999px;background:var(--bar);  
  border:1px solid var(--bar-edge);box-shadow:inset 0 0 0 1px rgba(255,255,255,.02), var(--glow);  
  overflow:hidden;  
}  
.bar .zone.low{position:absolute;left:0;top:0;bottom:0;width:50%;background:linear-gradient(90deg, rgba(255,138,31,.18), rgba(255,138,31,0));}  
.bar .zone.high{position:absolute;right:0;top:0;bottom:0;width:50%;background:linear-gradient(270deg, rgba(239,68,68,.18), rgba(239,68,68,0));}  
.bar .zone.ok{position:absolute;left:50%;transform:translateX(-50%);top:0;bottom:0;width:12%;background:linear-gradient(90deg, rgba(34,197,94,.3), rgba(34,197,94,.0) 60%);}  
.pointer{  
  position:absolute;top:50%;transform:translate(-50%,-50%);  
  width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-top:18px solid #eaf2ff;  
  filter:drop-shadow(0 4px 8px rgba(0,0,0,.6));  
}  
.readout{display:grid;gap:6px;justify-items:center;text-align:center}  
.note{font-size:clamp(28px,10vw,48px);font-weight:900;letter-spacing:1px}  
.status{font-size:clamp(16px,4vw,22px);font-weight:900;padding:6px 12px;border-radius:12px;background:var(--card);border:1px solid var(--line);min-width:140px}  
.status.low{color:var(--low);box-shadow:0 0 0 2px rgba(255,138,31,.15) inset}  
.status.high{color:var(--high);box-shadow:0 0 0 2px rgba(239,68,68,.15) inset}  
.status.ok{color:var(--ok);box-shadow:0 0 0 2px rgba(34,197,94,.15) inset}  
.help{font-size:12px;color:var(--muted)}  
.wrap.tuned{ background: radial-gradient(1200px 400px at 50% -200px, rgba(34,197,94,.12), transparent 60%), var(--bg); }  

footer{margin-top:8px;text-align:center;color:var(--muted);font-size:12px}  
.error{color:#fca5a5;font-size:13px}  
.meter{height:8px;border-radius:999px;background:#1f2a44;overflow:hidden;width:180px;border:1px solid var(--line)}  
.meter > div{height:100%;width:0;background:#3b82f6;transition:width .08s linear}  

/* Metronome */  
.metro{display:flex;gap:8px;align-items:center;flex-wrap:wrap}  
.metro .dots{display:flex;gap:6px}  
.metro .dot{width:12px;height:12px;border-radius:50%;background:#2b3757;border:1px solid var(--line)}  
.metro .dot.active{background:#eaf2ff}  
.metro .dot.accent{background:#22c55e}  
</style>  
</head>  
<body>  
<div class="wrap" id="app">  
  <header>  
    <div class="brand">  
      <!-- Put your logo in the repo root as 'logo.png' -->  
      <img class="logo" src="logo.png" alt="Ceol Gan Eagla logo" onerror="this.style.display='none'"/>  
      <span class="flag" title="Ireland"><div></div><div></div><div></div></span>  
      <h1>Ceol Gan Eagla Tuner</h1>  
    </div>  
    <div class="controls">  
      <button id="toggleBtn" class="toggle start">Start Mic</button>  
      <span class="badge" id="micStatus">Mic: Off</span>  
    </div>  
  </header>  

  <!-- Instrument + A4 reference + mic meter -->  
  <div class="panel">  
    <div class="row">  
      <div class="tray" id="instrumentTray" aria-label="Choose instrument">  
        <button class="instrument-btn active" data-inst="guitar">🎸<span>Guitar</span></button>  
        <button class="instrument-btn" data-inst="violin">🎻<span>Violin</span></button>  
        <button class="instrument-btn" data-inst="tenorbanjo">🪕<span>Tenor Banjo</span></button>  
        <button class="instrument-btn" data-inst="mandolin">🎶<span>Mandolin</span></button>  
        <button class="instrument-btn" data-inst="bouzouki">🎶<span>Bouzouki</span></button>  
        <button class="instrument-btn" data-inst="ukulele">🎵<span>Ukulele</span></button>  
        <button class="instrument-btn" data-inst="bass4">🎸<span>Bass</span></button>  
        <button class="instrument-btn" data-inst="viola">🎻<span>Viola</span></button>  
        <button class="instrument-btn" data-inst="cello">🎻<span>Cello</span></button>  
      </div>  

      <div class="tuning-controls">  
        <label class="badge" for="tuningSelect">Tuning</label>  
        <select id="tuningSelect" aria-label="Tuning options"></select>  

        <label class="badge" for="a4Select">A4</label>  
        <select id="a4Select" aria-label="Reference A4 (Hz)"></select>  
        <span class="badge" id="a4Show">A4=440</span>  

        <div style="display:flex;align-items:center;gap:8px">  
          <span class="badge">Mic Level</span>  
          <div class="meter"><div id="levelBar"></div></div>  
        </div>  
      </div>  
    </div>  

    <div class="row" style="margin-top:8px">  
      <div class="tuning"><strong>Tuning notes:</strong> <span id="tuningText">E A D G B E</span></div>  
      <div class="error" id="err"></div>  
    </div>  

    <div class="row">  
      <div class="string-row" id="stringRow"></div>  
    </div>  
  </div>  

  <!-- Tuning bar -->  
  <div class="panel bar-wrap">  
    <div class="bar" id="bar">  
      <div class="zone low"></div>  
      <div class="zone ok"></div>  
      <div class="zone high"></div>  
      <div class="pointer" id="pointer" style="left:50%"></div>  
    </div>  
    <div class="readout">  
      <div class="note" id="note">—</div>  
      <div class="status" id="status">Stopped</div>  
      <div class="help">Bar turns <b style="color:var(--ok)">green</b> when in tune; <span style="color:var(--low)">orange</span> = too low, <span style="color:var(--high)">red</span> = too high.</div>  
    </div>  
  </div>  

  <!-- Metronome -->  
  <div class="panel">  
    <div class="row metro">  
      <label class="badge" for="sigSelect">Time</label>  
      <select id="sigSelect">  
        <option value="4-4" selected>4/4</option>  
        <option value="6-8">6/8 (Jig)</option>  
        <option value="3-4">3/4</option>  
        <option value="2-4">2/4</option>  
      </select>  

      <label class="badge" for="bpmInput">Tempo</label>  
      <input id="bpmInput" type="number" min="30" max="240" value="100" style="width:84px;padding:8px 10px;border-radius:10px;border:1px solid var(--line);background:var(--card);color:var(--ink);font-weight:700"/>  

      <button id="metroBtn">Start Metronome</button>  
      <div class="dots" id="metroDots"></div>  
    </div>  
  </div>  

  <footer>© 2025 Gearóid MacUaid — Ceol Gan Eagla</footer>  
</div>  

<!-- Fit-to-screen auto-scaling (layout only) -->
<script>
(function(){
  const root = document.getElementById('app');
  function fit(){
    if(!root) return;
    root.style.transform='none';
    root.style.transformOrigin='top left';
    root.style.width=''; root.style.height='';
    const vw=window.innerWidth, vh=window.innerHeight;
    const w=root.scrollWidth, h=root.scrollHeight;
    const scale=Math.min(vw/w, vh/h, 1);
    root.style.width=w+'px';
    root.style.height=h+'px';
    root.style.transform='scale('+scale+')';
  }
  addEventListener('load', fit, {once:true});
  addEventListener('resize', fit);
  addEventListener('orientationchange', fit);
  setTimeout(fit, 0);
})();
</script>

<script>  
(() => {  
  // ======= Helpers & UI refs =======  
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];  
  const appEl = document.getElementById('app');  
  const toggleBtn = document.getElementById('toggleBtn');  
  const micStatus = document.getElementById('micStatus');  
  const tray = document.getElementById('instrumentTray');  
  const tuningSelect = document.getElementById('tuningSelect');  
  const a4Select = document.getElementById('a4Select');  
  const a4Show = document.getElementById('a4Show');  
  const pointer = document.getElementById('pointer');  
  const bar = document.getElementById('bar');  
  const noteEl = document.getElementById('note');  
  const statusEl = document.getElementById('status');  
  const tuningText = document.getElementById('tuningText');  
  const stringRow = document.getElementById('stringRow');  
  const errEl = document.getElementById('err');  
  const levelBar = document.getElementById('levelBar');  

  // Metronome refs  
  const sigSelect = document.getElementById('sigSelect');  
  const bpmInput = document.getElementById('bpmInput');  
  const metroBtn = document.getElementById('metroBtn');  
  const metroDots = document.getElementById('metroDots');  

  // ======= Tunings (with dropdowns) =======  
  const TUNINGS = {  
    guitar: {  
      "Standard (E A D G B E)": ["E2","A2","D3","G3","B3","E4"],  
      "Drop D (D A D G B E)": ["D2","A2","D3","G3","B3","E4"],  
      "Open G (D G D G B D)": ["D2","G2","D3","G3","B3","D4"],  
      "Open D (D A D F# A D)": ["D2","A2","D3","F#3","A3","D4"],  
      "DADGAD (D A D G A D)": ["D2","A2","D3","G3","A3","D4"]  
    },  
    tenorbanjo: {  
      "Irish (G D A E)": ["G2","D3","A3","E4"],  
      "Standard Tenor (C G D A)": ["C3","G3","D4","A4"]  
    },  
    bouzouki: {  
      "GDAE": ["G2","D3","A3","E4"],  
      "GDAD": ["G2","D3","A3","D4"]  
    },  
    mandolin:    { "Standard (G D A E)": ["G3","D4","A4","E5"] },  
    violin:      { "Standard (G D A E)": ["G3","D4","A4","E5"] },  
    ukulele:     { "Re-entrant (G C E A)": ["G4","C4","E4","A4"] },  
    bass4:       { "Standard (E A D G)": ["E1","A1","D2","G2"] },  
    viola:       { "Standard (C G D A)": ["C3","G3","D4","A4"] },  
    cello:       { "Standard (C G D A)": ["C2","G2","D3","A3"] }  
  };  

  function noteToHz(n, A4=440){  
    const m = /^([A-G])(#?)(-?\d+)$/.exec(n);  
    const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[m[1]];  
    const sharp = m[2] ? 1 : 0;  
    const oct = parseInt(m[3],10);  
    const index = base + sharp + (oct+1)*12; // C-1 index 0  
    const a4Index = 9 + (4+1)*12; // A4 index with this mapping = 57  
    return A4 * Math.pow(2, (index - a4Index)/12);  
  }  

  let currentInstrumentKey = 'guitar';  
  let currentTuningLabel = Object.keys(TUNINGS[currentInstrumentKey])[0];  
  let A4_REF = 440;  

  function buildA4Options(){  
    a4Select.innerHTML = "";  
    for (let v=436; v<=446; v++){  
      const o=document.createElement('option'); o.value=v; o.textContent=v; if (v===440) o.selected=true;  
      a4Select.appendChild(o);  
    }  
    a4Show.textContent = "A4="+A4_REF;  
  }  

  function buildTuningDropdown(){  
    tuningSelect.innerHTML = "";  
    const opts = Object.keys(TUNINGS[currentInstrumentKey]);  
    opts.forEach(l => {  
      const o=document.createElement('option'); o.value=l; o.textContent=l; tuningSelect.appendChild(o);  
    });  
    currentTuningLabel = opts.includes(currentTuningLabel) ? currentTuningLabel : opts[0];  
    tuningSelect.value = currentTuningLabel;  
  }  

  function renderTuningUI(){  
    const names = TUNINGS[currentInstrumentKey][currentTuningLabel].map(s => s.replace(/\d+$/,''));  
    tuningText.textContent = names.join(' ');  
    stringRow.innerHTML = '';  
    names.forEach((name,i)=>{  
      const chip = document.createElement('div');  
      chip.className = 'string-chip'; chip.textContent = name; chip.dataset.idx=i;  
      stringRow.appendChild(chip);  
    });  
  }  

  buildA4Options();  
  buildTuningDropdown();  
  renderTuningUI();  

  tray.addEventListener('click', (e)=>{  
    const btn = e.target.closest('.instrument-btn');  
    if(!btn) return;  
    [...tray.children].forEach(b=>b.classList.remove('active'));  
    btn.classList.add('active');  
    currentInstrumentKey = btn.dataset.inst;  
    buildTuningDropdown();  
    resetLock();  
    renderTuningUI();  
  });  

  tuningSelect.addEventListener('change', () => {  
    currentTuningLabel = tuningSelect.value;  
    resetLock();  
    renderTuningUI();  
  });  

  a4Select.addEventListener('change', () => {  
    A4_REF = parseInt(a4Select.value,10);  
    a4Show.textContent = "A4="+A4_REF;  
    // force recompute refs by releasing lock  
    resetLock();  
  });  

  // ======= Audio + Pitch (YIN) =======  
  let audioCtx=null, analyser=null, mediaStream=null, hpFilter=null, lpFilter=null;  
  const BUF_SIZE = 4096;  
  let buf = new Float32Array(BUF_SIZE);  
  let running=false;  

  // Stability / feel  
  let displayCents = 0;  
  let lock = {active:false, stringIdx:-1, expires:0};  
  let cand = {idx:-1, count:0};  

  // Sensitivity & smoothing (tweaked for quick response + creep + sustain)  
  let LEVEL_GATE = 0.006;      // lower so you don't have to pluck hard  
  const YIN_THRESH = 0.10;  
  const CONF_GATE  = 0.60;  
  const MIN_HZ=50, MAX_HZ=1200;  

  const SMOOTH_A = 0.95;       // higher = slower/creepier motion  
  const DEADBAND_CENTS = 1.2;  // ignore tiny jitter  
  const LOCK_NEED_FRAMES = 10; // quicker to lock the string  
  const LOCK_TIME_MS = 8000;   // hold lock longer  
  const PERFECT_CENTS = 3;     // “perfect” zone width  
  const HOLD_MS = 900;         // sustain the perfect state briefly  
  let lastPerfectUntil = 0;  

  const C_HISTORY = 7;  
  const centsHistory = [];  

  function resetLock(){ lock={active:false,stringIdx:-1,expires:0}; cand={idx:-1,count:0}; }  

  function rms(arr){ let s=0; for(let i=0;i<arr.length;i++){const v=arr[i]; s+=v*v;} return Math.sqrt(s/arr.length); }  
  function centsOff(f, ref){ return 1200 * Math.log2(f / ref); }  
  function freqToNote(f){  
    const n = Math.round(12 * Math.log2(f / A4_REF)) + 57;  
    const name = NOTE_NAMES[(n % 12 + 12) % 12];  
    const octave = Math.floor(n / 12) - 1;  
    return {name, octave};  
  }  
  function nearestStringIdx(hz){  
    const setNotes = TUNINGS[currentInstrumentKey][currentTuningLabel];  
    const setHz = setNotes.map(n => noteToHz(n, A4_REF));  
    let bestIdx=0, best=Math.abs(centsOff(hz, setHz[0]));  
    for (let i=1;i<setHz.length;i++){  
      const c = Math.abs(centsOff(hz, setHz[i]));  
      if (c < best){ best=c; bestIdx=i; }  
    }  
    return {idx:bestIdx, refs:setHz};  
  }  
  function median(arr){ const a = arr.slice().sort((x,y)=>x-y); const m = Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2; }  

  // YIN detector  
  function yin(buf, sampleRate){  
    const N = buf.length;  
    const tauMax = Math.min(Math.floor(sampleRate / 50), N-1);  
    const tauMin = Math.max(2, Math.floor(sampleRate / 1200));  
    const d = new Float32Array(tauMax+1);  
    for (let tau=tauMin; tau<=tauMax; tau++){  
      let sum = 0;  
      for (let i=0; i<N - tau; i++){ const diff = buf[i] - buf[i+tau]; sum += diff*diff; }  
      d[tau] = sum;  
    }  
    const cmnd = new Float32Array(tauMax+1);  
    let runningSum = 0;  
    for (let tau=tauMin; tau<=tauMax; tau++){  
      runningSum += d[tau];  
      cmnd[tau] = d[tau] * tau / (runningSum || 1);  
    }  
    let tau = -1;  
    for (let t=tauMin+1; t<=tauMax; t++){  
      if (cmnd[t] < YIN_THRESH && cmnd[t] < cmnd[t-1]){  
        tau = t; while (t+1 <= tauMax && cmnd[t+1] < cmnd[t]) { t++; tau = t; }  
        break;  
      }  
    }  
    if (tau === -1) return {hz:-1, conf:0};  
    const t0 = Math.max(tau-1, tauMin), t1=tau, t2=Math.min(tau+1, tauMax);  
    const s0=cmnd[t0], s1=cmnd[t1], s2=cmnd[t2];  
    const denom = (s0 - 2*s1 + s2);  
    const shift = denom !== 0 ? (s0 - s2) / (2*denom) : 0;  
    const tauEst = tau + shift;  
    const conf = Math.max(0, 1 - cmnd[tau]);  
    const hz = sampleRate / tauEst;  
    if (!isFinite(hz) || hz<MIN_HZ || hz>MAX_HZ) return {hz:-1, conf:0};  
    return {hz, conf};  
  }  

  function setPointerByCents(cents){  
    // creep + deadband  
    const clamp = Math.max(-50, Math.min(50, cents));  
    const delta = clamp - displayCents;  
    if (Math.abs(delta) < DEADBAND_CENTS) return;  
    displayCents = displayCents * SMOOTH_A + clamp * (1 - SMOOTH_A);  
    const t = (displayCents + 50) / 100;  
    pointer.style.left = (t*100) + "%";  
  }  

  async function getMicStream() {  
    const tries = [  
      { audio: { echoCancellation:true,  noiseSuppression:true,  autoGainControl:true,  channelCount:1, sampleRate:48000 } },  
      { audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false, channelCount:1, sampleRate:48000 } },  
      { audio: { channelCount:1 } },  
      { audio: true }  
    ];  
    let lastErr;  
    for (const c of tries) {  
      try { return await navigator.mediaDevices.getUserMedia(c); }  
      catch (e) { lastErr = e; }  
    }  
    throw lastErr;  
  }  

  async function start(){  
    errEl.textContent = "";  
    if (running) return;  
    if (location.protocol !== 'https:' && location.hostname !== 'localhost'){  
      errEl.textContent = "Mic needs HTTPS. Open via GitHub Pages (https://USERNAME.github.io/REPO/).";  
      return;  
    }  
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {  
      errEl.textContent = "This browser cannot access the microphone.";  
      return;  
    }  

    try { mediaStream = await getMicStream(); }  
    catch (err) {  
      const hint =  
        err.name === "NotAllowedError" ? "Permission blocked. Padlock → Site settings → Microphone → Allow, then reload." :  
        err.name === "NotFoundError"   ? "No microphone found/selected. Choose one in the browser’s mic settings." :  
        err.name === "NotReadableError"? "Mic busy in another app. Close other apps using the mic." :  
        err.name === "SecurityError"   ? "Needs HTTPS (use the GitHub Pages URL)." :  
        ("Mic error: " + err.name);  
      errEl.textContent = hint; return;  
    }  

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();  
    if (audioCtx.state !== "running") { try{ await audioCtx.resume(); }catch(e){} }  

    // Filters calm rumble/hiss  
    hpFilter = audioCtx.createBiquadFilter(); hpFilter.type="highpass"; hpFilter.frequency.value=50;  
    lpFilter = audioCtx.createBiquadFilter(); lpFilter.type="lowpass";  lpFilter.frequency.value=1800;  

    analyser = audioCtx.createAnalyser();  
    analyser.fftSize = BUF_SIZE;  
    analyser.smoothingTimeConstant = 0.06;  

    const src = audioCtx.createMediaStreamSource(mediaStream);  
    src.connect(hpFilter); hpFilter.connect(lpFilter); lpFilter.connect(analyser);  

    running = true;  
    toggleBtn.textContent = "Stop Mic";  
    toggleBtn.classList.remove('start'); toggleBtn.classList.add('stop');  
    micStatus.textContent = "Mic: On";  
    statusEl.textContent = "Listening…";  
    requestAnimationFrame(loop);  
  }  

  function stop(){  
    running = false;  
    if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }  
    if (audioCtx){ audioCtx.close().catch(()=>{}); audioCtx=null; }  
    analyser = hpFilter = lpFilter = null;  
    toggleBtn.textContent = "Start Mic";  
    toggleBtn.classList.remove('stop'); toggleBtn.classList.add('start');  
    micStatus.textContent = "Mic: Off";  
    statusEl.className = "status";  
    statusEl.textContent = "Stopped";  
    appEl.classList.remove('tuned');  
    pointer.style.left = "50%";  
    displayCents = 0;  
    centsHistory.length = 0;  
    resetLock();  
    [...stringRow.children].forEach(c=>c.className='string-chip');  
    levelBar.style.width = "0%";  
  }  

  toggleBtn.addEventListener('click', () => running ? stop() : start());  

  function loop(ts){  
    if (!running || !analyser) return;  

    analyser.getFloatTimeDomainData(buf);  

    // Mic level meter  
    let lsum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; lsum += v*v; }  
    const level = Math.sqrt(lsum/buf.length);  
    levelBar.style.width = Math.min(100, (level*600)) + "%";  

    const sr = audioCtx.sampleRate || 48000;  
    if (level < LEVEL_GATE){  
      // gentle decay toward center when quiet  
      displayCents = displayCents*0.985;  
      pointer.style.left = ((displayCents+50)/100*100)+"%";  
      if (performance.now() > lastPerfectUntil){  
        statusEl.className = "status";  
        statusEl.textContent = "Listening…";  
        appEl.classList.remove('tuned');  
      }  
      requestAnimationFrame(loop);  
      return;  
    }  

    const {hz, conf} = yin(buf, sr);  
    if (!(hz > 0 && conf > CONF_GATE)){  
      if (performance.now() > lastPerfectUntil){  
        statusEl.className = "status";  
        statusEl.textContent = "Listening…";  
        appEl.classList.remove('tuned');  
      }  
      requestAnimationFrame(loop);  
      return;  
    }  

    const {idx, refs} = nearestStringIdx(hz);  
    // lock logic (prevents hopping)  
    if (!lock.active){  
      if (cand.idx === idx) cand.count++; else { cand.idx=idx; cand.count=1; }  
      if (cand.count > LOCK_NEED_FRAMES){ lock={active:true,stringIdx:idx,expires:performance.now()+LOCK_TIME_MS}; cand={idx:-1,count:0}; }  
    } else {  
      if (performance.now() > lock.expires){ lock={active:false,stringIdx:-1,expires:0}; }  
      else { /* stick to locked string */ }  
    }  
    const useIdx = lock.active ? lock.stringIdx : idx;  
    const ref = refs[useIdx];  

    // cents & smoothing  
    let cents = 1200 * Math.log2(hz / ref);  
    centsHistory.push(cents); if (centsHistory.length > C_HISTORY) centsHistory.shift();  
    cents = median(centsHistory);  

    // Note label (chromatic display, but header says Tuner only)  
    const n = Math.round(12 * Math.log2(hz / A4_REF)) + 57;  
    const name = NOTE_NAMES[(n % 12 + 12) % 12];  
    const octave = Math.floor(n / 12) - 1;  
    noteEl.textContent = `${name}${octave}`;  

    const abs = Math.abs(cents);  
    let cls="status", txt="";  
    if (abs <= PERFECT_CENTS){  
      cls+=" ok"; txt="Perfect!";  
      appEl.classList.add('tuned');  
      bar.style.boxShadow="inset 0 0 0 2px rgba(34,197,94,.35), var(--glow)";  
      lastPerfectUntil = performance.now() + HOLD_MS; // brief sustain  
    } else if (cents < 0){  
      cls+=" low"; txt="Too Low";  
      appEl.classList.remove('tuned');  
      bar.style.boxShadow="inset 0 0 0 2px rgba(255,138,31,.25), var(--glow)";  
    } else {  
      cls+=" high"; txt="Too High";  
      appEl.classList.remove('tuned');  
      bar.style.boxShadow="inset 0 0 0 2px rgba(239,68,68,.25), var(--glow)";  
    }  

    // sustain display if we just had a perfect lock  
    if (performance.now() < lastPerfectUntil){ cls="status ok"; txt="Perfect!"; appEl.classList.add('tuned'); }  

    statusEl.className = cls; statusEl.textContent = txt;  

    // Needle creep  
    setPointerByCents(cents);  

    // String chips UI  
    [...stringRow.children].forEach((chip,i)=>{  
      chip.className = 'string-chip' + (i===useIdx ? ' active' : '');  
    });  
    if (lock.active && abs <= PERFECT_CENTS) stringRow.children[useIdx]?.classList.add('tuned');  

    requestAnimationFrame(loop);  
  }  

  // ======= Metronome (WebAudio) =======  
  let metroCtx=null, metroTimer=null, metroBeatCount=0, metroPattern=[];  
  function makePattern(sig){  
    // Returns [beats per bar, subdivision, accents array indices]  
    if (sig==="6-8"){ // jig feel: 6 pulses, strong accents on 1 and 4  
      return {pulses:6, accents:new Set([0,3])};  
    }  
    if (sig==="3-4"){ return {pulses:3, accents:new Set([0])}; }  
    if (sig==="2-4"){ return {pulses:2, accents:new Set([0])}; }  
    return {pulses:4, accents:new Set([0])}; // 4/4 default  
  }  
  function buildDots(){  
    metroDots.innerHTML = "";  
    const pat = makePattern(sigSelect.value);  
    for (let i=0;i<pat.pulses;i++){  
      const d=document.createElement('div');  
      d.className="dot";  
      metroDots.appendChild(d);  
    }  
  }  
  buildDots();  
  sigSelect.addEventListener('change', buildDots);  

  function tick(accent=false){  
    if (!metroCtx) metroCtx = new (window.AudioContext||window.webkitAudioContext)();  
    const t = metroCtx.currentTime + 0.01;  
    const o = metroCtx.createOscillator();  
    const g = metroCtx.createGain();  
    o.type = "square";  
    o.frequency.value = accent ? 1200 : 900;  
    g.gain.value = accent ? 0.15 : 0.10;  
    o.connect(g); g.connect(metroCtx.destination);  
    o.start(t); o.stop(t+0.05);  
  }  

  function startMetronome(){  
    if (metroTimer) return;  
    if (!metroCtx) metroCtx = new (window.AudioContext||window.webkitAudioContext)();  
    const pat = makePattern(sigSelect.value);  
    const bpm = Math.max(30, Math.min(240, parseInt(bpmInput.value,10)||100));  
    // For 6/8: pulse = eighth-note; for others: quarter-note pulse  
    const msPerPulse = sigSelect.value==="6-8" ? 60000/(bpm*1.5) : 60000/bpm;  

    metroBeatCount = 0;  
    metroTimer = setInterval(()=>{  
      const pulseIdx = metroBeatCount % pat.pulses;  
      const accent = pat.accents.has(pulseIdx);  
      tick(accent);  
      // visual  
      [...metroDots.children].forEach((d,i)=>{  
        d.className = "dot" + (i===pulseIdx ? " active" : "");  
        if (accent && i===pulseIdx) d.className += " accent";  
      });  
      metroBeatCount++;  
    }, msPerPulse);  
    metroBtn.textContent="Stop Metronome";  
  }  

  function stopMetronome(){  
    if (metroTimer){ clearInterval(metroTimer); metroTimer=null; }  
    if (metroCtx){ try{ metroCtx.close(); }catch(e){} metroCtx=null; }  
    [...metroDots.children].forEach(d=>d.className="dot");  
    metroBtn.textContent="Start Metronome";  
  }  

  metroBtn.addEventListener('click', ()=> metroTimer ? stopMetronome() : startMetronome());  
  bpmInput.addEventListener('change', ()=> { if (metroTimer){ stopMetronome(); startMetronome(); }});  
  sigSelect.addEventListener('change', ()=> { if (metroTimer){ stopMetronome(); startMetronome(); }});  
})();  
</script>  

<!-- register the service worker -->  
<script>  
if ("serviceWorker" in navigator) {  
  window.addEventListener("load", () => {  
    navigator.serviceWorker.register("./sw.js").catch(()=>{});  
  });  
}  
</script>  
</body>  
</html>

</body>
</html>

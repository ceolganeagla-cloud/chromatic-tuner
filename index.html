 <!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Ceol Gan Eagla â€” Tuner</title>
<meta name="theme-color" content="#0b1220"/>

<!-- Irish tricolour favicon (rectangular, green-white-orange leftâ†’right) -->
<link rel="icon" href='data:image/svg+xml;utf8,
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 48">
<rect width="64" height="48" fill="%23fff"/>
<rect x="0" y="0" width="21.333" height="48" fill="%2309a061"/>
<rect x="42.666" y="0" width="21.334" height="48" fill="%23ff7f4d"/>
</svg>'/>

<style>
:root{
  --bg:#0b1220; --panel:#0f172a; --card:#0c1324; --ink:#eaf2ff; --muted:#a4b0c0; --line:#1f2a44;
  --ok:#22c55e; --low:#ff8a1f; --high:#ef4444; --bar:#111a2e; --bar-edge:#1a2744; --glow:0 10px 30px rgba(0,0,0,.45);
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;overflow:hidden}

/* One-screen layout */
.app{
  height:100svh; width:100vw; max-width:960px; margin:0 auto;
  display:grid; gap:.9rem; padding:clamp(10px,2.6vw,16px);
  grid-template-rows:auto auto 1fr auto; /* header / instruments / center / footer */
}
header{display:flex;align-items:center;justify-content:space-between;gap:.75rem}
.title{display:flex;align-items:center;gap:.55rem;font-weight:900;letter-spacing:.3px;font-size:clamp(18px,5vw,28px)}
.flag{
  width:1.8em;height:1.2em;border-radius:4px;overflow:hidden;display:inline-block;box-shadow:0 0 0 1px rgba(255,255,255,.08), 0 2px 6px rgba(0,0,0,.35);
  background:
    linear-gradient(90deg,#09a061 0 33.333%,white 33.333% 66.666%,#ff7f4d 66.666% 100%);
}
.controls{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center}
button{
  appearance:none;border:1px solid var(--line);background:var(--panel);color:var(--ink);
  padding:.6rem .9rem;border-radius:16px;font-weight:800;cursor:pointer;box-shadow:var(--glow);
  font-size:clamp(13px,3.6vw,15px)
}
button.toggle.start{background:#16a34a;color:white;border-color:#106c31}
button.toggle.stop{background:#b91c1c;color:white;border-color:#7f1212}
.badge{padding:.45rem .7rem;border-radius:999px;background:var(--panel);border:1px solid var(--line);font-weight:700;color:var(--muted);font-size:clamp(11px,3.2vw,13px)}
select, input[type="number"]{
  background:var(--card); color:var(--ink); border:1px solid var(--line); border-radius:12px;
  padding:.45rem .6rem; font-weight:700; font-size:clamp(12px,3.2vw,14px); outline:none
}

/* Cards */
.panel{background:var(--panel);border:1px solid var(--line);border-radius:18px;padding:.7rem;box-shadow:var(--glow)}
.row{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;justify-content:space-between}

/* Instrument tray */
.tray{display:flex;flex-wrap:wrap;gap:.5rem;max-height:24vh;overflow:auto}
.instrument-btn{
  display:flex;align-items:center;gap:.4rem;padding:.5rem .65rem;border-radius:14px;
  background:var(--card);border:1px solid var(--line);cursor:pointer;font-weight:800;color:var(--ink);
  font-size:clamp(12px,3.4vw,14px)
}
.instrument-btn.active{outline:2px solid #3b82f6}
.instrument-btn.tuned{background:#0e2919;border-color:#1f8a4e}

/* Tuning + strings */
.tuning{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;color:var(--muted);font-size:clamp(12px,3.2vw,14px)}
.string-row{display:flex;gap:.45rem;flex-wrap:wrap}
.string-chip{
  padding:.4rem .6rem;border:1px solid var(--line);background:var(--card);border-radius:999px;
  font-weight:900;color:var(--ink);min-width:2.3rem;text-align:center;font-size:clamp(12px,3.4vw,14px)
}
.string-chip.active{outline:2px solid #3b82f6}
.string-chip.tuned{background:#0e2919;border-color:#1f8a4e}

/* Center (bar + readout + metronome) */
.center{display:grid;grid-template-rows:auto 1fr auto;gap:.7rem;min-height:0}
.bar-wrap{display:grid;gap:.6rem}
.bar{
  position:relative;height:clamp(36px,7.5vh,56px);border-radius:999px;background:var(--bar);
  border:1px solid var(--bar-edge);box-shadow:inset 0 0 0 1px rgba(255,255,255,.02), var(--glow);
  overflow:hidden;min-height:34px
}
.bar .zone.low{position:absolute;left:0;top:0;bottom:0;width:50%;background:linear-gradient(90deg, rgba(255,138,31,.18), rgba(255,138,31,0));}
.bar .zone.high{position:absolute;right:0;top:0;bottom:0;width:50%;background:linear-gradient(270deg, rgba(239,68,68,.18), rgba(239,68,68,0));}
.bar .zone.ok{position:absolute;left:50%;transform:translateX(-50%);top:0;bottom:0;width:12%;background:linear-gradient(90deg, rgba(34,197,94,.3), rgba(34,197,94,.0) 60%);}
.pointer{
  position:absolute;top:50%;transform:translate(-50%,-50%);
  width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-top:18px solid #eaf2ff;
  filter:drop-shadow(0 4px 8px rgba(0,0,0,.6));
}

.readout{display:grid;gap:.4rem;justify-items:center;text-align:center}
.note{font-size:clamp(28px,10vw,44px);font-weight:900;letter-spacing:1px}
.status{font-size:clamp(15px,4vw,20px);font-weight:900;padding:.4rem .7rem;border-radius:12px;background:var(--card);border:1px solid var(--line);min-width:130px;text-align:center}
.status.low{color:var(--low);box-shadow:0 0 0 2px rgba(255,138,31,.15) inset}
.status.high{color:var(--high);box-shadow:0 0 0 2px rgba(239,68,68,.15) inset}
.status.ok{color:var(--ok);box-shadow:0 0 0 2px rgba(34,197,94,.15) inset}
.help{font-size:clamp(11px,3vw,13px);color:var(--muted)}
.app.tuned{ background: radial-gradient(1200px 380px at 50% -180px, rgba(34,197,94,.10), transparent 60%), var(--bg); }

footer{text-align:center;color:var(--muted);font-size:11px}

/* Error + meters */
.error{color:#fca5a5;font-size:12px}
.meter{height:8px;border-radius:999px;background:#1f2a44;overflow:hidden;width:150px;border:1px solid var(--line)}
.meter > div{height:100%;width:0;background:#3b82f6;transition:width .1s linear}

/* Metronome */
.met-wrap{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;justify-content:center}
.pulse{width:10px;height:10px;border-radius:50%;background:#2c3552;box-shadow:0 0 0 1px var(--line) inset}
.pulse.on{background:#eaf2ff;box-shadow:0 0 12px rgba(255,255,255,.6)}
</style>
</head>
<body>
<div class="app" id="app">
  <header>
    <div class="title"><span class="flag" aria-hidden="true"></span><span>Ceol Gan Eagla â€” Chromatic Tuner</span></div>
    <div class="controls">
      <button id="toggleBtn" class="toggle start">Start Mic</button>
      <span class="badge" id="micStatus">Mic: Off</span>
    </div>
  </header>

  <!-- Instruments + tuning + mic level -->
  <div class="panel">
    <div class="row">
      <div class="tray" id="instrumentTray" aria-label="Choose instrument">
        <button class="instrument-btn active" data-inst="guitar">ðŸŽ¸ Guitar</button>
        <button class="instrument-btn" data-inst="violin">ðŸŽ» Violin</button>
        <button class="instrument-btn" data-inst="tenorbanjo">ðŸª• Tenor Banjo</button>
        <button class="instrument-btn" data-inst="mandolin">ðŸŽ¶ Mandolin</button>
        <button class="instrument-btn" data-inst="bouzouki_gdae">ðŸŽ¶ Bouzouki GDAE</button>
        <button class="instrument-btn" data-inst="bouzouki_gdad">ðŸŽ¶ Bouzouki GDAD</button>
        <button class="instrument-btn" data-inst="ukulele">ðŸŽµ Ukulele</button>
        <button class="instrument-btn" data-inst="bass4">ðŸŽ¸ Bass</button>
        <button class="instrument-btn" data-inst="viola">ðŸŽ» Viola</button>
        <button class="instrument-btn" data-inst="cello">ðŸŽ» Cello</button>
      </div>
      <div style="display:flex;gap:.5rem;align-items:center">
        <label class="badge" for="tuningSel">Tuning</label>
        <select id="tuningSel" title="Select tuning"></select>
        <label class="badge" for="a4">A4</label>
        <input id="a4" type="number" min="430" max="450" step="1" value="440" title="A4 reference (Hz)" />
        <span class="badge">Mic Level</span>
        <div class="meter"><div id="levelBar"></div></div>
      </div>
    </div>

    <div class="row" style="margin-top:.4rem">
      <div class="tuning"><strong>Tuning notes:</strong> <span id="tuningText">E A D G B E</span></div>
      <div class="error" id="err"></div>
    </div>

    <div class="row">
      <div class="string-row" id="stringRow"></div>
      <span class="badge" id="modeBadge">Mode: Auto string detect</span>
    </div>
  </div>

  <!-- Center: tuner bar + readout + metronome -->
  <div class="center">
    <div class="panel bar-wrap">
      <div class="bar" id="bar">
        <div class="zone low"></div>
        <div class="zone ok"></div>
        <div class="zone high"></div>
        <div class="pointer" id="pointer" style="left:50%"></div>
      </div>
      <div class="readout">
        <div class="note" id="note">â€”</div>
        <div class="status" id="status">Stopped</div>
        <div class="help">Bar turns <b style="color:var(--ok)">green</b> when in tune; <span style="color:var(--low)">orange</span> = too low, <span style="color:var(--high)">red</span> = too high.</div>
      </div>
    </div>

    <div class="panel">
      <div class="met-wrap">
        <label class="badge" for="metTime">Time</label>
        <select id="metTime">
          <option>2/4</option><option>3/4</option><option selected>4/4</option><option>6/8</option>
        </select>
        <label class="badge" for="metTempo">Tempo</label>
        <input id="metTempo" type="number" min="30" max="240" step="1" value="100"/>
        <button id="metToggle">Start Metronome</button>
        <div class="pulse" id="metPulse" title="beat"></div>
      </div>
    </div>
  </div>

  <footer>Â© 2025 GearÃ³id MacUaid â€” Ceol Gan Eagla</footer>
</div>

<script>
(() => {
  let A4 = 440;
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

  /* Tunings per instrument */
  const TUNINGS = {
    guitar: {
      "Standard (E A D G B E)": ["E2","A2","D3","G3","B3","E4"],
      "Drop D (D A D G B E)": ["D2","A2","D3","G3","B3","E4"],
      "DADGAD (D A D G A D)": ["D2","A2","D3","G3","A3","D4"],
      "Open G (D G D G B D)": ["D2","G2","D3","G3","B3","D4"],
      "Open D (D A D F# A D)": ["D2","A2","D3","F#3","A3","D4"]
    },
    violin: { "Standard (G D A E)": ["G3","D4","A4","E5"] },
    tenorbanjo: { "Standard (G D A E)": ["G2","D3","A3","E4"] },
    mandolin: { "Standard (G D A E)": ["G3","D4","A4","E5"] },
    bouzouki_gdae: { "GDAE (G D A E)": ["G2","D3","A3","E4"] },
    bouzouki_gdad: { "GDAD (G D A D)": ["G2","D3","A3","D4"] },
    ukulele: {
      "Re-entrant (G C E A)": ["G4","C4","E4","A4"],
      "Low G (G C E A)": ["G3","C4","E4","A4"]
    },
    bass4: { "Standard (E A D G)": ["E1","A1","D2","G2"] },
    viola: { "Standard (C G D A)": ["C3","G3","D4","A4"] },
    cello: { "Standard (C G D A)": ["C2","G2","D3","A3"] },
  };

  /* Frequency map from note name */
  function noteToHz(note){
    // Parse like "F#3"
    const m = note.match(/^([A-G])(#?)(\d)$/); if(!m) return 0;
    const base = "C C# D D# E F F# G G# A A# B".split(" ");
    const name = m[1] + (m[2]||"");
    const octave = parseInt(m[3],10);
    // MIDI semantics: A4 = 440 is MIDI 69. C-1 => 0
    const index = base.indexOf(name);
    const midi = (octave+1)*12 + index;
    const a4midi = 69;
    return A4 * Math.pow(2, (midi - a4midi)/12);
  }

  /* Build instrument maps with Hz */
  function buildInstrument(instKey){
    const obj = {};
    for (const [label, notes] of Object.entries(TUNINGS[instKey])) {
      obj[label] = notes.map(n => ({ n, f: noteToHz(n) }));
    }
    return obj;
  }

  // UI refs
  const appEl = document.getElementById('app');
  const toggleBtn = document.getElementById('toggleBtn');
  const micStatus = document.getElementById('micStatus');
  const tray = document.getElementById('instrumentTray');
  const pointer = document.getElementById('pointer');
  const bar = document.getElementById('bar');
  const noteEl = document.getElementById('note');
  const statusEl = document.getElementById('status');
  const tuningSel = document.getElementById('tuningSel');
  const tuningText = document.getElementById('tuningText');
  const stringRow = document.getElementById('stringRow');
  const errEl = document.getElementById('err');
  const levelBar = document.getElementById('levelBar');
  const a4Input = document.getElementById('a4');

  // Metronome refs
  const metTime = document.getElementById('metTime');
  const metTempo = document.getElementById('metTempo');
  const metToggle = document.getElementById('metToggle');
  const metPulse = document.getElementById('metPulse');

  /* State */
  let currentInstrumentKey = 'guitar';
  let INST = buildInstrument(currentInstrumentKey); // {label: [{n,f}..]}
  let currentTuningLabel = Object.keys(INST)[0];

  function renderTuningSelector(){
    tuningSel.innerHTML = '';
    for (const label of Object.keys(INST)){
      const opt = document.createElement('option');
      opt.value = label; opt.textContent = label;
      tuningSel.appendChild(opt);
    }
    tuningSel.value = currentTuningLabel;
  }

  function renderTuningUI(){
    const inst = INST[currentTuningLabel];
    const names = inst.map(s => s.n.replace(/\d+$/,''));
    tuningText.textContent = names.join(' ');
    stringRow.innerHTML = '';
    inst.forEach((s, i) => {
      const chip = document.createElement('div');
      chip.className = 'string-chip';
      chip.textContent = s.n.replace(/\d+$/,'');
      chip.dataset.idx = i;
      stringRow.appendChild(chip);
    });
  }

  function rebuildInstrument(){
    INST = buildInstrument(currentInstrumentKey);
    currentTuningLabel = Object.keys(INST)[0];
    renderTuningSelector();
    renderTuningUI();
  }

  renderTuningSelector();
  renderTuningUI();

  tray.addEventListener('click', (e)=>{
    const btn = e.target.closest('.instrument-btn');
    if(!btn) return;
    [...tray.children].forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentInstrumentKey = btn.dataset.inst;
    rebuildInstrument();
  });

  tuningSel.addEventListener('change', ()=>{
    currentTuningLabel = tuningSel.value;
    renderTuningUI();
  });

  a4Input.addEventListener('change', ()=>{
    A4 = Math.max(430, Math.min(450, parseInt(a4Input.value||440,10)));
    rebuildInstrument();
  });

  /* ---------- Audio + Tuner ---------- */
  let audioCtx=null, analyser=null, mediaStream=null, hpFilter=null, lpFilter=null;
  const BUF_SIZE = 4096;
  let buf = new Float32Array(BUF_SIZE);
  let running=false;

  let displayCents = 0, lock={active:false,stringIdx:-1,expires:0}, cand={idx:-1,count:0};
  const LEVEL_GATE = 0.012, YIN_THRESH=0.10, CONF_GATE=0.6, MIN_HZ=50, MAX_HZ=1200;
  const SMOOTH_A=0.92, DEADBAND_CENTS=1.5, LOCK_NEED_FRAMES=14, LOCK_TIME_MS=6000, C_HISTORY=7;
  const centsHistory = [];

  function rms(a){ let s=0; for(let i=0;i<a.length;i++){const v=a[i]; s+=v*v;} return Math.sqrt(s/a.length); }
  function centsOff(f, ref){ return 1200 * Math.log2(f / ref); }
  function freqToNote(f){
    const n = Math.round(12 * Math.log2(f / A4)) + 57;
    const name = NOTE_NAMES[(n % 12 + 12) % 12]; const octave = Math.floor(n / 12) - 1;
    return {name, octave};
  }
  function nearestStringIdx(hz, inst){
    let best = {idx:0, cents:Infinity};
    for (let i=0;i<inst.length;i++){
      const c = Math.abs(centsOff(hz, inst[i].f));
      if (c < best.cents) best = {idx:i, cents:c};
    }
    return best.idx;
  }
  function median(arr){ const a = arr.slice().sort((x,y)=>x-y); const m = Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2; }

  function yin(buffer, sampleRate){
    const N = buffer.length;
    const tauMax = Math.min(Math.floor(sampleRate / 50), N-1);
    const tauMin = Math.max(2, Math.floor(sampleRate / 1200));
    const d = new Float32Array(tauMax+1);
    for (let tau=tauMin; tau<=tauMax; tau++){
      let sum = 0;
      for (let i=0; i<N - tau; i++){ const diff = buffer[i] - buffer[i+tau]; sum += diff*diff; }
      d[tau] = sum;
    }
    const cmnd = new Float32Array(tauMax+1);
    let runningSum = 0;
    for (let tau=tauMin; tau<=tauMax; tau++){
      runningSum += d[tau];
      cmnd[tau] = d[tau] * tau / (runningSum || 1);
    }
    let tau = -1;
    for (let t=tauMin+1; t<=tauMax; t++){
      if (cmnd[t] < YIN_THRESH && cmnd[t] < cmnd[t-1]){
        tau = t; while (t+1 <= tauMax && cmnd[t+1] < cmnd[t]) { t++; tau = t; }
        break;
      }
    }
    if (tau === -1) return {hz:-1, conf:0};
    const t0 = Math.max(tau-1, tauMin), t1=tau, t2=Math.min(tau+1, tauMax);
    const s0=cmnd[t0], s1=cmnd[t1], s2=cmnd[t2];
    const denom = (s0 - 2*s1 + s2);
    const shift = denom !== 0 ? (s0 - s2) / (2*denom) : 0;
    const tauEst = tau + shift;
    const conf = Math.max(0, 1 - cmnd[tau]);
    const hz = sampleRate / tauEst;
    if (!isFinite(hz) || hz<MIN_HZ || hz>MAX_HZ) return {hz:-1, conf:0};
    return {hz, conf};
  }

  function setPointerByCents(cents){
    const clamp = Math.max(-50, Math.min(50, cents));
    const delta = clamp - displayCents;
    if (Math.abs(delta) < DEADBAND_CENTS) return;
    displayCents = displayCents * SMOOTH_A + clamp * (1 - SMOOTH_A);
    const t = (displayCents + 50) / 100;
    pointer.style.left = (t*100) + "%";
  }

  async function getMicStream() {
    const tries = [
      { audio: { echoCancellation:true,  noiseSuppression:true,  autoGainControl:true,  channelCount:1, sampleRate:48000 } },
      { audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false, channelCount:1, sampleRate:48000 } },
      { audio: { channelCount:1 } },
      { audio: true }
    ];
    let lastErr;
    for (const c of tries) {
      try { return await navigator.mediaDevices.getUserMedia(c); }
      catch (e) { lastErr = e; }
    }
    throw lastErr;
  }

  async function start(){
    errEl.textContent = "";
    if (running) return;

    if (location.protocol !== 'https:' && location.hostname !== 'localhost'){
      errEl.textContent = "Mic needs HTTPS. Open via GitHub Pages.";
      return;
    }
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      errEl.textContent = "This page cannot access the microphone.";
      return;
    }

    try { mediaStream = await getMicStream(); }
    catch (err) {
      const hint =
        err.name === "NotAllowedError" ? "Permission blocked. Padlock â†’ Site settings â†’ Microphone â†’ Allow, then reload." :
        err.name === "NotFoundError"   ? "No microphone found/selected. Choose one in Chromeâ€™s mic settings." :
        err.name === "NotReadableError"? "Mic busy in another app. Close other apps using the mic." :
        err.name === "SecurityError"   ? "Needs HTTPS (use the GitHub Pages URL)." :
        ("Mic error: " + err.name);
      errEl.textContent = hint; return;
    }

    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    try { await audioCtx.resume(); } catch(e){}
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    try { await audioCtx.resume(); } catch(e){}

    hpFilter = audioCtx.createBiquadFilter(); hpFilter.type="highpass"; hpFilter.frequency.value=50;
    lpFilter = audioCtx.createBiquadFilter(); lpFilter.type="lowpass";  lpFilter.frequency.value=1800;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = BUF_SIZE;
    analyser.smoothingTimeConstant = 0.06;

    const src = audioCtx.createMediaStreamSource(mediaStream);
    src.connect(hpFilter); hpFilter.connect(lpFilter); lpFilter.connect(analyser);

    running = true;
    toggleBtn.textContent = "Stop Mic";
    toggleBtn.classList.remove('start'); toggleBtn.classList.add('stop');
    micStatus.textContent = "Mic: On";
    statusEl.textContent = "Listeningâ€¦";
    requestAnimationFrame(loop);
  }

  function stop(){
    running = false;
    if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
    if (audioCtx){ audioCtx.close().catch(()=>{}); audioCtx=null; }
    analyser = hpFilter = lpFilter = null;
    toggleBtn.textContent = "Start Mic";
    toggleBtn.classList.remove('stop'); toggleBtn.classList.add('start');
    micStatus.textContent = "Mic: Off";
    statusEl.className = "status"; statusEl.textContent = "Stopped";
    appEl.classList.remove('tuned');
    pointer.style.left = "50%";
    displayCents = 0; centsHistory.length = 0; lock = {active:false,stringIdx:-1,expires:0}; cand = {idx:-1,count:0};
    [...stringRow.children].forEach(c=>c.className='string-chip');
    levelBar.style.width = "0%";
  }

  toggleBtn.addEventListener('click', () => running ? stop() : start());

  function loop(){
    if (!running || !analyser) return;

    analyser.getFloatTimeDomainData(buf);
    // Mic level meter
    let lsum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; lsum += v*v; }
    const level = Math.sqrt(lsum/buf.length);
    levelBar.style.width = Math.min(100, (level*500)) + "%";

    const sr = audioCtx.sampleRate || 48000;
    if (level < LEVEL_GATE){ statusEl.className="status"; statusEl.textContent="Listeningâ€¦"; appEl.classList.remove('tuned'); return requestAnimationFrame(loop); }

    const {hz, conf} = yin(buf, sr);
    if (!(hz>0 && conf>CONF_GATE)){ statusEl.className="status"; statusEl.textContent="Listeningâ€¦"; appEl.classList.remove('tuned'); return requestAnimationFrame(loop); }

    const inst = INST[currentTuningLabel];
    let idx = nearestStringIdx(hz, inst);

    if (!lock.active){
      if (cand.idx === idx) cand.count++; else { cand.idx=idx; cand.count=1; }
      if (cand.count > LOCK_NEED_FRAMES){ lock={active:true,stringIdx:idx,expires:performance.now()+LOCK_TIME_MS}; cand={idx:-1,count:0}; }
    } else {
      if (performance.now() > lock.expires){ lock={active:false,stringIdx:-1,expires:0}; }
      else { idx = lock.stringIdx; }
    }

    const ref = inst[idx].f;
    let cents = 1200 * Math.log2(hz / ref);
    centsHistory.push(cents); if (centsHistory.length > C_HISTORY) centsHistory.shift();
    cents = median(centsHistory);

    const note = freqToNote(hz);
    noteEl.textContent = `${note.name}${note.octave}`;

    const abs = Math.abs(cents);
    let cls="status", txt="";
    if (abs <= 5){ cls+=" ok"; txt="In Tune"; appEl.classList.add('tuned'); bar.style.boxShadow="inset 0 0 0 2px rgba(34,197,94,.35), var(--glow)"; }
    else if (cents < 0){ cls+=" low"; txt="Too Low"; appEl.classList.remove('tuned'); bar.style.boxShadow="inset 0 0 0 2px rgba(255,138,31,.25), var(--glow)"; }
    else { cls+=" high"; txt="Too High"; appEl.classList.remove('tuned'); bar.style.boxShadow="inset 0 0 0 2px rgba(239,68,68,.25), var(--glow)"; }
    statusEl.className = cls; statusEl.textContent = txt;

    const clamp = Math.max(-50, Math.min(50, cents));
    const delta = clamp - displayCents;
    if (Math.abs(delta) >= DEADBAND_CENTS) {
      displayCents = displayCents * SMOOTH_A + clamp * (1 - SMOOTH_A);
      const t = (displayCents + 50) / 100; pointer.style.left = (t*100) + "%";
    }
    [...stringRow.children].forEach((chip,i)=>{
      chip.className = 'string-chip' + (i===idx ? ' active' : '');
    });
    if (lock.active && abs <= 5) stringRow.children[idx]?.classList.add('tuned');

    requestAnimationFrame(loop);
  }

  /* --- Chrome Android mic wake-up patch --- */
  document.addEventListener('click', async () => {
    if (audioCtx && audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch {} }
  }, { once: true });
  navigator.mediaDevices.ondevicechange = async () => {
    if (running && (!mediaStream || mediaStream.getTracks().every(t=>!t.enabled))) { stop(); setTimeout(start, 600); }
  };

  /* ---------- Metronome ---------- */
  let metCtx=null, metGain=null, metTimer=null, metLook=25, metSchedAhead=0.1, metNext=0, metBeat=0, metBeatsPerBar=4;
  const accentFreq = 1700, tickFreq = 1000;
  function metEnsureCtx(){
    if (!metCtx) {
      metCtx = new (window.AudioContext || window.webkitAudioContext)();
      metGain = metCtx.createGain(); metGain.gain.value = 0.2; metGain.connect(metCtx.destination);
    }
  }
  function metClick(t, accent){
    const osc = metCtx.createOscillator(); const g = metCtx.createGain();
    osc.type = "square"; osc.frequency.value = accent ? accentFreq : tickFreq;
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(accent?0.35:0.22, t+0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.06);
    osc.connect(g); g.connect(metGain);
    osc.start(t); osc.stop(t+0.07);
  }
  function metSchedule(){
    const tempo = Math.max(30, Math.min(240, parseInt(metTempo.value||100,10)));
    const secPerBeat = 60/tempo;
    while (metNext < metCtx.currentTime + metSchedAhead){
      const accent = (metBeat % metBeatsPerBar) === 0;
      metClick(metNext, accent);
      // tiny UI pulse
      setTimeout(()=>{ metPulse.classList.add('on'); setTimeout(()=>metPulse.classList.remove('on'), 70); }, (metNext - metCtx.currentTime)*1000);
      metNext += secPerBeat;
      metBeat = (metBeat + 1) % metBeatsPerBar;
    }
  }
  function metTick(){
    metSchedule();
    metTimer = setTimeout(metTick, metLook);
  }
  function metStart(){
    metEnsureCtx();
    metCtx.resume();
    // beats per bar from time select
    const ts = metTime.value;
    metBeatsPerBar = (ts==="6/8") ? 6 : parseInt(ts,10) || 4;
    const tempo = Math.max(30, Math.min(240, parseInt(metTempo.value||100,10)));
    const secPerBeat = 60/tempo;
    metNext = metCtx.currentTime + 0.05;
    metBeat = 0;
    metTick();
    metToggle.textContent = "Stop Metronome";
  }
  function metStop(){
    if (metTimer) clearTimeout(metTimer); metTimer=null;
    try{ metCtx && metCtx.suspend(); }catch(e){}
    metToggle.textContent = "Start Metronome";
  }
  metToggle.addEventListener('click', ()=> (metTimer ? metStop() : metStart()));
  metTime.addEventListener('change', ()=>{ if (metTimer){ metStop(); metStart(); }});
  metTempo.addEventListener('change', ()=>{ if (metTimer){ metStop(); metStart(); }});
})();
</script>
</body>
</html>
